\chapter{Evaluation}

In the previous chapter we have proposed an algorithm that finds an efficient distribution of any given quantum circuit. Additionally, we have given two extensions (\S\ref{pulCNOTs} and \S\ref{BothEnds}) that allow the algorithm to apply some extra optimisations. In this chapter, we will evaluate the distributed circuits our algorithm generates for a collection of quantum programs. The quantum programs we consider have been discussed in the literature as examples of what we would like to run on quantum computers.

The code of our algorithm's implementation, all the generated executables and all the data discussed in this chapter can be found at: \textbf{TODO}: GitHub. 


\section{Implementation details}
\label{implementation}

The algorithm described in \S\ref{Vanilla} and its two extensions (\S\ref{pulCNOTs} and \S\ref{BothEnds}) have been implemented in Haskell. We chose Haskell because Quipper, a quantum circuit description language, is embedded on it. The quantum programs we use in our evaluation (see \S\ref{benchmark}) are all available as part of the Quipper system, so using Haskell we could easily manage them. Our implementation provides a Quipper circuit as output, and thus it can be integrated in any Quipper program. Besides, the hypergraph partitioning is performed by an specialised third-party software, \texttt{KaHyPart} \citep{KaHyPart}, that is called by our program when needed. A brief overview of \texttt{KaHyPart} is given in Appendix~\ref{HypPart}. 

The main contributions of this thesis were described in Chapter~\ref{Project}. Our implementation is meant to be a demonstration of our algorithm, and it is intended for evaluation purposes only. Thus, efficiency was not a main concern. Nevertheless, it is efficient enough to manage circuits with up to \(300\) wires within a reasonable amount of resources (see \S\ref{Results}).

Our implementation receives a circuit described in Quipper's internal data structure and outputs its distributed version, also in Quipper's format. However, along the process the circuit is managed as a list of gates, rather than using Quipper's internal data structure. This is the main cause of inefficiencies in our code. Quipper is presented to its users as a language to define circuits, rather than a language to define circuit transformations. Therefore, there are not enough functionalities available at user-level to fully implement our algorithm within Quipper. If we intended to achieve better efficiency, we would require to learn the internal workings -- the back-end -- of Quipper, which is beyond the scope of this thesis.

Once our input circuit is converted\footnote{This conversion and its backwards counterpart are provided by Quipper.} from Quipper's data structure to a standard list of gates, implementing our algorithm is straight-forward. Depending on two input flags, the extensions from \S\ref{pulCNOTs} and \S\ref{BothEnds} are applied or not; and the parameters \(k,\epsilon\) -- number of QPUs and load-imbalance tolerance -- are also given as input. The hypergraph generated by Algorithm~\ref{code:buildHypVanilla} (or Algorithm~\ref{code:buildHypBothEnds}) is written in a file using \texttt{KaHyPart}'s format, and the resulting partition is read from \texttt{KaHyPart}'s output file and used to create the distributed circuit as described in \S\ref{Vanilla}.


\section{Test suite}
\label{benchmark}

The quantum programs we will use to evaluate our algorithm are available as part of the Quipper system. On the date this thesis is written, the Quipper system provides seven quantum programs, each with their own default configuration parameters. We use four of these seven examples, with their default configuration unless stated otherwise. The three programs we omit in our evaluation either lack an explicit -- gate by gate -- implementation of some fragment of their circuits, or their size is beyond the capabilities of our implementation (see \S\ref{implementation}). Detailed information about each of these quantum programs can be found in Quipper's online documentation\footnote{Link to Quipper's documentation: \url{https://www.mathstat.dal.ca/~selinger/quipper/doc/}.}. The four programs we consider are the following:

\begin{itemize}
\item \textit{Boolean Formula (BF)}: \citet{BFWalk} showed that the problem of evaluating a boolean formula over \(N\) variables could be solved in time \(\sqrt{N}\) on a quantum computer. We consider the circuit implementing the main part of the algorithm -- the quantum walk. Implemented by A. Green.

\item \textit{Binary Welded Tree (BWT)}: \citet{BWT} proposed the problem of finding a path between two nodes in a particular kind of graph (a binary welded tree), and gave a quantum program that solves it exponentially faster than any known classical algorithm. We consider the circuit implementing the overall algorithm, making the tree height twice as large as the default Quipper's input. Implemented by P. Selinger and B. Valiron.

\item \textit{Ground State Estimation (GSE)}: \citet{GSE} proposed how to efficiently calculate the energy of a molecular system's ground state, which is relevant in chemistry. We consider the circuit implementing the overall algorithm. We doubled the number of basis functions and the number of occupied orbitals. Implemented by A. Green et al.

\item \textit{Unique Shortest Vector (USV)}: \citet{USV} proposed a problem where some characteristic vector of an input lattice must be found. This problem requires a large amount of resources, so we only consider a part of it, labelled `R' in Quipper's library. We reduced the default dimension of the lattice from \(5\) to \(2\). Implemented by N. Ross.
\end{itemize}

Apart from these four programs, we will include in our test suite the circuit for the \textit{Quantum Fourier Transform (QFT)}. The QFT is a key component of many quantum algorithms, Shor's factorisation algorithm being one of them. Its implementation is also provided in Quipper's libraries. In \S\ref{Results} we consider the QFT for different values of the dimension parameter \(N\), with the corresponding circuit having \(N+1\) qubits.

\section{Results}
\label{Results}

GHC version, -O2, Ubuntu...

8GB RAM, quickest: 5min, longest 90min, mainly depending on the number of hyperedges.

%\subsection{}

Comparison, for each example, between number of original CNOTs, number of hyperedges, number of non local CNOTs and number of ebits

Discuss increase in wires

Discuss hypergraph sizes then: Show with QFT for different sizes how at some point having both extensions is too much for the HypPart to handle

